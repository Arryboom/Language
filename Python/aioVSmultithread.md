#多线程与协程爬虫有很大区别吗？多线程转协程能优化多少？
>https://www.v2ex.com/t/696184#reply39


400 个线程，你 cpu 不瓶颈就怪了。。。。。
现代的程序一般是一个线程对应 cpu 的一个核心性能才比较好，开 400 个线程和以前单核 cou 跑多线程一样性能没什么提升反倒降低性能

这个情况用协程应该能改善楼主的 cpu 和内存使用情况，而且协程可以实现比多线程更高的并发（协程可以一次轻松发出几千几万个请求，你用线程难道开几千个几万个线程么）
当然你网络带宽死的话，协程也只是比线程更省资源罢了


---

之前爬斗鱼直播弹幕，第一版爬虫用的多线程，5 台服务器最多能同时监控 250 个房间的弹幕。后来使用 asyncio 重构成异步爬虫，只用 3 台机器，可以同时监控 25000 个房间。

---

异步编程要考虑不能引入同步的代码，而 Python 的生态目前来讲，大部分库仍然是同步的，因此强行上异步，会造成开发效率的下降，而性能却不见得能比用多线程快很多

我们最后得出的结论是，除非有一个场景，特别适合使用 asyncio，否则一般还是倾向于使用多线程

---

现在一般普通主流计算机，直接开几万协程确实没问题。以前开发写测试时，不小心开了几十万协程，还能跑。但是线程却不行，资源占用和上下文切换决定了它不可能开启同样多的数量时还能保证可用。
你的怀疑点应该是一次性发出这么多请求。这得看理解了，如果指发出第一个数据包开始，确实可能。
假设极端情况，被访问的服务器响应很慢，导致发出数据包请求后就在 io 等待。那么协程确实能做到同时有几万个请求在等待响应。只是线程要做到同样量级，需要机器资源就更多了。
不过实际上并没有优势，现实中不会这么极端，瓶颈通常也不在这。

---


Talk is cheap, 试试就知道了

直接说结论:

1. 本次测试不记带宽发送本地端口的请求, 本地 server 使用 golang 默认的 net/http 简单实现的

2. 对比 httpx 协程和 requests 多线程, 二者都使用连接池复用连接. 前者比后者快了大概 20%(虽然后者被我负优化了...), 启用 uvloop 以后也没拉开太大差距.

3. 对比 aiohttp 和 requests, 不使用 uvloop 的时候前者是后者 3 倍, 开了 uvloop 大概 3068 qps, 是后者的 3.15 倍, 而 golang 内置的 net/http 测试也才 3300. 虽然很大因素是 aiohttp 内核很多地方使用 Cython 实现的...

4. 对比 windows vs linux, 前者是游戏本所以多核(但是只能用一个...), 后者在阿里云服务器上虽然单 CPU 但是有 uvloop 加成, 速度提高一倍

部分代码: https://github.com/ClericPy/torequests#benchmarks


一句话总结, 以上测试纯属娱乐不作数, 真想用快的, 就选 aiohttp 就好了

之前貌似还看到, 裸 uvloop 单核情况下和 golang 差不多

---

IO 复用不光是解决内核态开销问题，还有一个大问题是解决线程切片时间的问题啊。

你以为的多线程+GIL：一个线程执行完了释放 GIL，切换到下一个线程，申请 GIL，开始业务逻辑
实际的多线程+GIL：一个线程执行完了释放 GIL，等待很长时间，系统 call 你了才能切换

---


看到有几个回复挺反常识的, 提醒几个 Python 并发编程的常识问题吧

1. 线程开的越多, 执行起来就越快吗?

并不会.

一方面, 线程开太多, CPU 切换的成本会变高, 也就相对降低了 CPU 利用率, CPU 很多时间浪费在调度上而不是计算上. 有关怎么切换的, 可以随处找找 GIL 的文章, 不过还是不建议自己修改对应参数 setswitchinterval (旧版本的 setcheckinterval )
另一方面, 对爬虫来说, 如果连接速度靠谱的话, 有可能一个线程就跑满了带宽, 那开多线程除了让所有任务一起抢资源, 并不会降低总时长, 也就是常见场景: 为什么我开 5 线程比开 100 线程还快(或者差不多). 与普通程序不同, 爬虫程序传输数据一方面看你的带宽, 另一方面还特别看重目标服务器的负载能力.

2. 有一个比较合理的并发数量吗?

参考:
Python3 里面 ThreadPoolExecutor 的 max_workers 默认值是 (os.cpu_count() or 1) * 5
可以根据带宽使用率适当调整这个数值.
(另: 多进程 ProcessPoolExecutor 默认 max_workers 就是 os.cpu_count() or 1)


3. 不计带宽和 CPU 能力的情况下, 是不是线程开的越多, 速度越快?

也不完全是.

拿 Requests 库来举例, 它的 Session 默认连接池大小取决于 HTTPAdapter 对象的 pool_connections, 这个默认值 DEFAULT_POOLSIZE = 10
简单的说, 如果不修改 HTTPAdapter 连接池的大小, 那可能瓶颈基本限定在这里了. 至于有些人选择不用 Session 复用连接, 我举个例子算了: 之前抓某东的某数据, 复用连接的情况下速度比每次新建连接大概快了十几倍.

4. 是不是用协程就比线程快, 节省 CPU?

不一定.

协程提高的是 CPU 效率, 遇到高并发的抓取, 你会发现协程 CPU 一直 100%, 因为它真的很忙, 而多线程反而可能在 80~100% 波动. 至于速度, 简单的提个例子, falcon 那是相当擅长 Benchmark.

协程中最使我受益的并不是性能, 而是它属于随时可以 Cancel 的, 一个已经执行的线程, 想在外部杀死它简直太费劲了.

